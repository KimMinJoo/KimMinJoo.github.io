---
layout: post
title: 알고리즘스터디] HASH
---

해시(Hash)는 계산 과정을 거치면서 작아진 값.<br>
입력 -> 분해/조립 -> 해시의 과정을 통해 해시를 구한다.<br>
Ex) 1065 -> 분해/조립 -> 15 (1065의 해시 15를 구했다.)<br>
<br>
해시는 어떤 과정을 거쳐 작아진 '값'을 의미하므로 해시값이라고도 한다.<br>
또 책에 따라 해시 코드라고도 한다.<br>
즉 해시 = 해시값 = 해시코드 이다.<br>


앞으로는 관련 알고리즘을 다룰 텐데 그 전에 몇가지 용어 정리.
#### 해시 함수
- 해시의 개념에서 해시를 구하는 과정이 입력 -> 분해/조립 -> 해시라고 했는데 이 과정을 해싱이라 칭한다.<br>
해싱에서 분해/조립 단계를 해시 함수라고 한다.<br>
즉 해시 함수는 분해 및 조립등의 연산을 통해 입력값을 해시로 만드는 함수이다.<br>
해시 함수의 중요한 점은 구해진 해시가 다른 해시와 구별되는 고유한 값이어야 한다는 점이다.<br>
Ex) 101의 해시와 202의 해시는 다르다.<br>
이 점은 해시함수의 경쟁력이라고 볼 수 있다.<br>

#### 해시 검색
- 검색 키에 대한 해시를 계산하여 검색하는 방법.<br>
Ex) 학번으로 학생 자료를 찾으려는 경우 학번이 검색 키가 된다.<br>
즉 학번이 입력값이 되고 해시 함수를 거쳐 해시가 나오게된다.<br>
여기서 해시는 검색하려는 자료의 주소가 된다고 했을때 해당 자료가 저장된 위치로 곧장 접근이 가능하다.

#### 해시 테이블
- 해시 함수로 계산한 주소에 따라 자료를 저장하는 자료 구조<br>
해시 테이블은 일반적으로 주소를 통해 바로 접근할 수 있는 배열을 선호한다.<br>
해시 테이블은 N개의 버킷(Bucket)으로 이루어져 있습니다.


#### 버킷
- 해시테이블에서 자료를 저장하는 단위로 하나의 고유한 해시에 대응하여 실제 자료가 저장되는 곳.


#### 해싱
- 해시뒤에 ing가 붙은 단어로 '해시를 만든다'는 뜻이다.<br>
해싱의 경우 해시를 구하는 과정을 의미하고 해시는 '값'자체를 의미한다.



## 2. 해시 검색
해시검색은 해시를 이용하여 검색을 하는것으로 다른 검색알고리즘과 비교해 속도가 월등히 빠르다는 장점이 있다.





### 2.1 해시검색의 기본 개념
해시검색에서는 해시키라는 개념이 있는데 해시키는 내가 찾고자 하는 자료를 가리키는 값을 말한다.<br>
학생자료를 찾는 예시를 들어서 설명.<br>
검색키는 학번이 되고 계산된 해시는 검색하려는 자료의 위치가 된다.<br>
예를들어 학번이 2016102라는 학생이 해시함수를 거쳤을 때 2라는 해시값을 가진다고 했을때,
2는 2016102학번을 가진 학생의 자료가 저장된 주소가 된다.<br>
따라서 해당 자료가 저장된 위치로 곧장 접근할 수 있다.<br>
여기서 헤시테이블은 학생자료가 저장된 테이블이다.<br>
2016102학생의 학생자료는 2번 버킷에 저장되어있다.<br>
참고로 버킷에는 한개의 자료만 저장할수도 슬롯이라는걸 두고 여러개의 자료를 저장할 수도 있다.





### 2.2 해시검색의 과정
### 2.2.1 자료 추가
해시검색을 하기 위해선 자료가 해시테이블에 미리 저장이 되어있어야 한다.<br>
자료 추가의 경우 아래와 같은 3단계를 거친다.<br>
주소계산 -> 해시테이블 확인 -> 자료저장.

#### 주소계산
- 주소 계산의 경우 전달받은 자료의 '검색키'로 자료를 저장할 버킷의 주소를 계산하는 단계다.<br>
이 과정을 거치는 이유는 위에서 예를 든 학번을 예로들면 0000000 ~ 9999999까지 모두 10^7개만큼 값이 생길 수 있다.<br>
반면 실제 해시 테이블의 경우 어떤 구조를 가지냐에따라 다르겠지만 00 ~ 99까지의 버켓을 둔다면 10^2개만큼만 저장할 수 있다.<br>
값의 범위가 대략 10만배 작아진다.<br>
이렇게 범위가 줄어드는 이유는 해시함수를 거치며 입력값이 작아지기 때문이다.<br>
해시함수에서 값을 줄이는 방법은 뒤쪽에서 설명.

#### 해시테이블 확인
해시테이블 확인단계의경우 주소계산단계에서 계산된 주소(해시)를 가지고 해시 테이블을 확인한다.<br>
자료가 저장될 주소를 알고도 확인을 하는 이유는 계산된 주소에 이미 다른 자료가 저장되어있는 경우때문이다.<br>
물론 자료가 저장되어있지않으면 바로 저장을 한다.<br>
하지만 이미 자료가 있어서 자료를 저장하지 못하는 경우가 발생할 수 있다.<br>
이 경우를 충돌(Collision)이라고 한다.<br>
<br>
Ex)
<pre>
| 검색키 |해시|<br>
| 2016102|   2|<br>
| 2016202|   2|<br>
</pre>
충돌이 발생하면 자료를 저장할 수 있는 새로운 주소를 다시 계산해야한다.<br>
해시 충돌의 경우 상당히 난처한 상황으로 이에 대처하기위한 다양한 방법이 제시되어있다.<br>
이런 해시 충돌 방안의 경우 뒤쪽에서 설명.

#### 자료저장
실제 해시테이블에 자료를 저장하는 단계.<br>
2단계에서 확인 후 빈 주소라면 자료를 저장하고 충돌이 발생했다면 다른 주소를 찾아서 저장한다.





### 2.2.2 자료 검색
자료 검색의 경우 아래와 같은 2단계를 거친다.<br>
주소계산 -> 해시테이블 확인

#### 주소계산
- 전달받은 '검색키'값으로 버킷의 주소를 계산한다. 즉 해시함수를 이용하여 입력값에 대한 해시를 구한다.

#### 해시테이블 확인
- 주소 계산에서 계산한 해시를 통해 해시테이블에 정말 자료가 저장되어있는지 확인한다.





## 3.해시함수
위에서 얘기했듯이 해시의 핵심은 바로 해시함수다.<br>
어떤 해시함수를 사용하느냐에 따라 해시 검색의 성능이 결정되기 때문이다.<br>
구체적인 내용으로 들어가기전에 해시함수의 조건을 살펴보자.

#### 충돌발생빈도
- 충돌이 많이 발생한다는 것은 비어있는 주소가 있음에도 비어있지 않은 주소에 반복해서 저장할 가능성이 크다는 것으로 충돌발생빈도는 낮을수록 좋다.

#### 해시테이블사용률(분포율)
- 해시 테이블을 고르게 분포시킬 수 있는 해시 함수가 저장 공간 활용 효율면에서 좋다.

#### 해시함수계산속도
- 해시검색에 걸리는 시간을 감소시키기 때문에 효율면에서 좋다.





### 3.1 나머지 함수
해시함수에서 가장 쉽게 사용할 수 있는 함수중 하나이다.<br>
나머지함수는 검색키 k를 해시테이블의 크기 M으로 나눈 나머지를 해시로 사용한다.<br>
Ex)<br>
<pre>
| k | M |hash|<br>
|125|100|  25|<br>
| 15|  7|   1|<br>
</pre>

다만 나머지 함수를 해시 함수로 사용할 경우 테이블 크기 M이 소수일 수록 충돌 발생 빈도가 낮아진다.<br>
충돌발생빈도가 낮다는 뜻은 해시테이블사용률 또한 높아진다는 뜻이다.<br>
따라서 나머지 함수를 사용할 경우 될수있으면 M은 소수로 하는것이 좋다.<br>

*** 나머지 함수를 사용할 때 M이 소수여야 하는 이유 ***<br>
해시맵의 경우 주소값이 입력값으로 들어온다. 이때 주소값의 경우 2n, 즉 짝수이다.<br>
입력값이 짝수이고 M이 홀수일 경우 짝수만 반복되어 들어온다.<br>
입력값이 짝수이고 M이 홀수일 경우 모든 숫자가 동일한 확률로 균일하게 들어온다면 나머지가 고르게 분포한다.<br>
하지만 입력값과 M이 최대공약수를 가질 경우 그 최대 공약수의 배수들만 나머지로 나오게된다.<br>
따라서 입력값이 고르게 분포되었다면 소수나 홀수나 차이가없다.<br>
그러나 현실에선 입력값이 고르게 분포되지 않을 경우가 많으므로 최대 공약수를 가질 확률이 적은 소수로 하는것이 해시테이블사용률을 높일 수 있다.




### 3.2 접기 함수
접기함수(혹은 접지합수)는 검색키를 먼저 분해하고 분해된 부분들을 조합하여 해시를 만드는 방법을 말한다.<br>
보통 검색키의 크기가 해시테이블의 크기보다 큰 경우에 많이 사용한다.<br>
접기 함수의 경우 세부 구현 방법에 따라 다양한 적용이 가능하다. 여기서는 대표적인 이동 접기 함수, 경계 접기 함수에 대해서 설명하겠다.





### 3.2.1 이동 접기 함수
이동 접기 함수는 분해된 부분들을 이동시킨 다음에 각 부분을 조합하는 접기 방법을 말한다.<br>
<br>
Ex) 검색키 1234512345에 대해서 이동 접기 함수로 해시를 구하는 과정.<br>
검색키 - 1234512345, 10자리<br>
해시테이블크기 - 99, 3자리<br>

#### 분해 단계
접기함수에서는 가장 먼저 검색 키를 분해한다. 보통 검색키의 크기가 해시 테이블의 크기보다 크기때문에 해시 테이블의 크기(자릿수)로 검색키를 분해한다.<br>
123,451,234,5 와 같이 분해한다.<br>
10자리의 검색키가 해시 테이블의 크기인 3에 따라 모두 분해됐다.<br>

#### 이동 및 더하기 단계
앞서 분해 단계에서 분해한 4개의 키를 오른쪽 맞춤으로 이동한다.<br>
여기서 오른쪽 맞춤이란 결국 자릿수가 작으면 일의자리 쪽으로 맞춘다는 뜻이다.<br>
Ex)<br>
123<br>
451<br>
234<br>
  5<br>
오른쪽 맞춤을 한 뒤 전부 더해준다.<br>
123 + 451 + 234 + 5 = 813<br>
1234512345의 검색키와 해시테이블의 크기가 999일 경우 이동 접기 함수를 이용하면 해시가 813이 나온다.<br>
이동 접기 결과가 1234와 같이 해시테이블크기보다 클 경우 짤라내고 234만 해시로 취한다.




### 3.2.2 경계 접기 함수
경계 접기 함수는 이동 접기 함수와 마찬가지로 '접기'를 기본적인 계산방법으로 사용하고있다.<br>
다만 이동하기 부분에서 차이점이있고 분해 및 더하기는 같다.<br>

#### 분해하기
분해는 이동 접기 함수와 마찬가지로 입력값 1234512345, M 999일 때
123,451,234,5로 나뉘어 진다.<br>
이 분해된 4부분중 먼저 기준이 되는 부분은 가장 오른쪽에 있는 부분이다. (여기선 5)<br>
기준부분은 경계 부분이 아니게 되고 그 다음부분인 234가 경계부분이된다.<br>
이때 경계부분은 서로 인접할 수 없어서 451의 경우 경계부분이 아니게 된다.<br>
따라서 그 다음 부분인 123이 경계부분이 된다.<br>
즉 경계부분은 123, 234부분이 되며 경계가 아닌부분이 451,5가 된다.

#### 이동하기
이 부분이 이동 접기 함수와 다른부분으로 경계부분은 뒤집기 처리를 해준다.<br>
즉 321,451,432,5로 분해된 4부분이 변하게 된다.<br>
이렇게 뒤집는 이유는 기존 숫자의 자릿수를 변경함으로써 충돌 확률을 낮추기 위해서이다.

#### 더하기
321 + +451 + 432 + 5 = 1209로 초과 자릿수는 버려지므로 해시는 209가 된다.




### 3.3 중간 제곱 함수
중간 제곱 함수는 검색 키의 일부분에서 해시를 채취하는 방법이다.<br>
특이점으로는 원래 검색키에서 값을 추출하는 것이 아니라 먼저 검색키의 제곱값을 구하고 그 제곱된 값중에서 중간 부분을 잘라내어 해시를 구한다.<br>
<br>
Ex)검색키 9415, 해시테이블의 크기 M 9999<br>
9415 * 9415 = 89321401<br>
M이 4자리이므로 가운데 4자리를 꺼내 해시로 사용한다.<br>
즉 해시는 3214가 된다.



### 3.4 숫자 분석 기반의 해시 함수
마지막으로 살펴볼 해시 함수는 숫자 분석 기반의 해시함수이다.<br>
여기서 '숫자 분석 기반'의 뜻은 검색키가 어떠한 특징이 있는지 검색키의 특성을 알아낸다는 뜻이다.<br>
<br>
숫자로 이루어진 검색키가 있다고 가정했을때 숫자 분석기반인 해시함수에서는 먼저 각 자릿수의 분포를 분석한다.<br>
Ex) '학번'으로 해시를 구하는 경우.<br>
검색키 : 2016-1025 (첫네자리인 2016은 입학년도, 그다음 두자리인 10은 학과번호, 그다음 두자리인 25는 같은 학과내의 학생 고유 번호)<br>
학번의 처음 4자리는 입학년도이기때문에 그해에 입학한 학생들은 모두 같은값을 가진다.<br>
그러나 그 뒤의 4자리는 학과 및 학생 고유번호이기때문에 비교적 고르게 분포되어있다.<br>
입학년도의 경우 많은 수의 학생이 가지고있으므로 해시함수의 입력값에 부적합하고 뒤의 4자리가 입력값에 적합하다.<br>
따라서 이 경우 1025가 해시함수의 입력값으로 적합하다.<br>





### 3.5 이외의 해시 함수들
진법 변환 함수, 비트 추출 함수, 가상 난수 기법등이 존재한다.<br>
또한 현재까지의 예시들에선 입력값이 정수일 경우만 가정해서 진행했다.<br>
하지만 입력값이 문자열인경우는 어떻게 해야할까?<br>
입력값이 문자열인경우 문자열을 구성하는 각 문자를 아스키코드로 변환시킨다.<br>
그 뒤 모든 문자열을 사용할지 혹은 처음문자만 사용할지등을 정해서 입력값으로 정해주면된다.<br>




## 4. 충돌 해결 방법
충돌이 발생했을 때 두가지 방법이 있다.

#### 개방주소법
- 충돌이 일어난 키 값을 비어 있는 다른 주소를 찾아 저장

#### 체이닝
- 여러 개의 항목을 저장할 수 있도록 해시 테이블의 구조를 변경




### 4.1 개방 주소법
개방 주소법은 어떻게 '다음주소'를 계산할지에 따라서 선형 조사법, 제곱 조사법, 이중 해싱등의 기법으로 나뉜다.





### 4.1.1 선형 조사법
충돌이 발생한 경우 일정한 상수만큼 증가시켜서 다시 조사하는 방법.<br>
Ex) 해시테이블의 주소 h에서 충돌이 발생할 경우 주소를 1만큼씩 증가시켜 다시 조사.<br>
즉, 선형주소법에서는 발생한 주소에서 일정한 상수를 더해가면서 선형적으로 주소를 찾아가는 방식이다.<br>
<br>
Ex)try_count를 더하는 방법( 상수가 1 )<br>
h(k) = (k + try_count) mod M<br>
h(k) ->  충돌 -> h(k+1) -> 충돌 -> h(k+2) -> ......<br>
물론 이방법의 경우 해시 테이블의 모든 주소가 차있을 때 실패하게된다.<br>
<br>
또한 선형조사법의 단점으로는 한번 충돌이 일어나게되면 충돌이 발생한 주소 주위로 자료가 뭉치는 군집화 현상이 발생한다.<br>
Ex) M = 5, 해시함수 = 나머지함수, 저장되는 검색 키 값 = {1, 3, 8, 13}, 증가되는 상수 = 1<br>
h(1) = 1, h(3) = 3, h(8) = 3 -> 4, h(13) = 3 -> 4 -> 5<br>
<br>
이 예시를 통해 선형 조사법의 경우 충돌과 군집화 현상이 잘 일어나는것을 확인했다<br>.





### 4.1.2 제곱조사법
충돌이 발생할 경우 주소를 조사 횟수의 제곱만큼 증가시켜 다시 조사하는 방법.<br>
1차 충돌에는 1^2, 2차 충돌에는 2^2, 3차충돌에는 3^2, ......, n차 충돌에는 n^2<br>
식으로 표현할 경우 아래와 같다.<br>
h(k) = (k + try_count^2) mod M<br>
<br>
제곱조사법의 단점으로는 선형 조사법에 비해 군집화가 덜 발생하지만 아직도 군집화가 발생할 가능성이 높은편이다.<br>
또한 해시 테이블의 모든 주소를 조사하려면 해시 테이블의 크기가 반드시 소수여야한다는 제약사항이 있다.<br>
<br>
Ex) M = 5, 해시함수 = 나머지함수, 저장되는 검색 키 값 = {1, 3, 8, 13}, 증가되는 상수 = 1<br>
h(1) = 1, h(3) = 3, h(8) = 3 -> 4, h(13) = 3 -> 4 -> -> 3 -> 2<br>





### 4.1.3 이중 해시
충돌이 발생하면 원래의 해시함수와는 다른 추가적인 해시 함수를 이용해 다시 조사하는 방법.<br>
어떤 해시함수를 사용할지에 따라서 다양한 방법이 있다.<br>
가장 간단한 방법으로는 다음과 같은 조사 간경을 이용하는 방법이 있다.<br>
Ex)조사간격(증가되는 상수) = M - (k mod M)<br>
M = 5, 해시함수 = 나머지함수, 저장되는 검색 키 값 = {1, 3, 8, 13}, 증가되는 상수 = 1<br>
h(1) = 1, h(3) = 3,<br>
h(8) = 3<br>
=> 조사간격 = 5 - (8 mod 5) = 2<br>
=> (3 + 2) mod 5<br>
= 0,<br>
h(13) = 3<br>
=> 조사간격 5 - (3 mod 5) = 2<br>
=> (3 + 2) mod 5<br>
=> (0 + 2) mod 5<br>
= 2<br>




### 4.2 체이닝(Chaining) 기법
체이닝은 해시 테이블의 각 버킷에 하나 이상의 검색키를 저장하는 방법이다.<br>
개방주소법에서는 버킷 하나당 하나의 검색키만 저장했기 때문에 충돌이 발생하면 '다음주소'를 계산하여 저장하는 방법을 사용했다.<br>
하지만 체이닝은 각 버킷에 연결 리스트를 사용하여 충돌이 발생할 때 동적으로 여러개의 키 값을 저장할 수 있게 한다.<br>
<br>
같은 버킷의 다른 슬롯에 저장된다는 것은 '충돌'이 일어났다는것을 뜻한다.<br>
같은 슬롯에 저장된다는 것은 '충돌' 즉 해시가 같고 검색키도 같다는 것을 의미한다.<br>
같은 버킷 다른 슬롯에 저장된다는 것은 '충돌' 즉 해시는 같으나 검색키가 다르다는 것을 의미한다. 이를 동거자(Synonym)라고 한다.<br>
<br>
보통 체이닝은 링크드리스트를 이용하여 같은 버킷에 여러 개의 Synonym을 저장할 수 있도록 한다.<br>
링크드리스트를 사용하여 구현하기 때문에 버킷내에서 내가 찾으려는 검색키를 검색하려면 Synonym들을 선형검색(head->tail)로 탐색해야 한다.<br>
<br>
Ex)<br>
해시테이블크기 :5<br>
해시 함수 : 나머지함수(mod)<br>
저장되는 검색 키 값 : {1, 8, 3}<br>
<br>
1 -> 1 mod 5 -> 1<br>
8 -> 8 mod 5 -> 3<br>
3 -> 3 mod 5 -> 3<br>
<br>
1 -> 1 -> NULL<br>
2 -> NULL<br>
3 -> 8 -> 3 -> NULL<br>
4 -> NULL<br>
5 -> NULL<br>


