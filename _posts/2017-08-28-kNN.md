---
layout: post
title: kNN 알고리즘
---
### k-최근접 이웃 알고리즘(k-Nearest Neighbors)

1.동작방식<br>
트레이닝 데이터가 있으며 모든 데이터는 분류항목표시(labels)가 붙어 있다.<br>
따라서 각가의 데이터가 어떤 분류항목으로 구분되는지 알 수 있다.<br>
이후 새로운 데이터가 주어졌을 때 기존의 모든 데이터와 비교한다.<br>
그리고 가장 유사한(근접한) 데이터의 분류 항목 표시를 살펴본다.<br>
이때, 분류 항목을 이미 알고 있는 데이터 집합에서 상위 k개의 유사한 데이터를 살펴본다.<br>
그 뒤 k개의 가장 유사한 데이터들 중 다수결을 통해 새로운 데이터의 분류 항목을 결정한다.<br>

- 장점
    - 높은 정확도
    - 오류데이터에 둔감
    - 데이터에 대한 가정이 없음
    
- 단점
    - 계산비용이 높음
    - 많은 메모리 요구
    
- 적용
    - 수치형
    - 명목형

- 기본 개념
   - 훈련집합의 모든 데이터에 '분류항목'이 존재하며 훈련집합의 분류항목을 통해 새로운 데이터를 학습시키는 알고리즘.
   - 분류 항목이 없는 새로운 데이터의 학습법
        - 이미 분류항목을 알고있는 데이터 집합에서 상위 k개를 뽑아 다수결을 통해 결정한다.


2.sudo 코드<br>
<pre>
데이터 집합에 있는 모든 측정값 반복<br>
    입력값과 현재 데이터 사이의 거리 계산<br>
    오름차순으로 거리 정렬<br>
    가장 가까운 거리에 있는 데이터 k개 추출<br>
    k개 데이터에서 가장 많은 분류 찾기<br>
가장많은 분류 반환<br>
</pre>


3.코드
```python
def kNNAlgorithm(inX, dataSet, labels, k):
    #shape함수의 경우 array의 모양을 나타냄 위의 createDataSet에 따르면 4,2의 행렬이므로 [0]은 4, [1]은 2를 나타낸다.
    dataSetSize = dataSet.shape[0]
    #inX의 값으로 (dataSetSize,1)사이즈로 만들고 dataSet만큼 빼 dataSet과의 X축거리, Y축거리를 확보한다
    diffMat = tile(inX, (dataSetSize, 1)) - dataSet
    #거리를 구하기위해 제곱을 한다.
    sqDiffMat = diffMat ** 2
    print(sqDiffMat)
    #axis = 0은 행  1은 열을 의미함. 행별로 더하는게 아니라 열별로 더한다.
    sqDistances = sqDiffMat.sum(axis = 1)
    #루트를 씌워 최종 거리를 구한다.
    distances = sqDistances ** 0.5
    #거리별로 index들을 정렬한다.
    sortedDistIndicies = distances.argsort()
    classCount={}
    for i in range(k):
        #가장 가까운 인덱스들의 라벨을 꺼낸다.
        voteIlabel = labels[sortedDistIndicies[i]]
        #classCount dictionary에서 각 라벨의 횟수를 가져와 1을 올려준다. 다만 없을경우 0으로 가져온다.
        classCount[voteIlabel] = classCount.get(voteIlabel, 0) + 1
    #dictionary 정렬 itemgetter가 0이면 키기준, 1이면 value기준
    sortedClassCount = sorted(classCount.items(), key = operator.itemgetter(1), reverse = True)
    #정렬된 dictionary에서 가장 첫밸류 리턴.
    return sortedClassCount[0][0]
```


4.예제<br>
헬렌이라는 사람이 데이트사이트에서 추천인을 받아서 데이트를 했을 때<br>
좋아하지 않았던 사람들, 조금 좋아했던사람들, 많이 좋아했던 사람들이 있던것을 알고,<br>
앞으로 만날 사람들을 걸러내기위해 분류를 하기위해 만든 프로그램.
- 데이터
    - 머신러닝 인 액션에서 제공된 데이터<br>
- 데이터 형식 
    - 연간 항공 마일리지 수
    - 비디오 게임으로 보내는 시간의 비율
    - 주당 아이스크림 소비량(L)
    - 라벨
- 라벨
    - 좋아하지 않았던 사람들
    - 조금 좋아했던 사람들
    - 많이 좋아했던 사람들
- 분석
    - 데이터를 시각적으로 보여주기 위해 matplot라이브러리 사용<br>
- 훈련
    - kNN알고리즘에는 적용되지 않음
- 검사
    - 헬렌이 준 검사용 예제 데이터의 일부를 사용하기 위한 함수 작성
    - 검사용 예제는 검사에 사용되지 않는 예제에 반해 분류되어있다
    - 예측된 분류 항목이 실질적인 분류 항목과 일치하지 않으면 오류
- 사용
    - 헬렌이 입력한 몇 가지 데이터를 토대로 누구를 좋아할지 예측하는 커넨드라인 프로그램

4.1. 예제 첫단계 : 텍스트 파일의 데이터 구문 분석하기
```python
'''
file을 matrix로 변환시켜주는 함수
filename 파일이름
k 파일 한 줄에 들어가있는 데이터의 수
'''
def file2matrix(filename, k):
    #파일을 읽는다.
    fr = open(filename)
    #파일의 각 줄로 배열을 만든다.
    arrayOfLines = fr.readlines()
    #파일의 전체 줄 수.
    numberOfLines = len(arrayOfLines)
    #0으로된 (파일줄수, k)의 matrix를 만든다.
    returnMat = zeros((numberOfLines,k))
    #라벨을 따로 저장할 라벨 배열.
    classLabelVector = []
    index = 0
    #각 라인의 데이터를 매트릭스와 라벨베열에 넣어준다.
    for line in arrayOfLines:
        #문자 양끝 공백제거. (필요에 따라 생략가능)
        line = line.strip()
        #라인을 tab기준으로 스플릿하여 리스트로 만든다.
        listFromLine = line.split('\t')
        #매트릭스의 index번째에 리스트를 넣어준다.
        returnMat[index,:] = listFromLine[0:k]
        #데이터 마지막에 있는 라벨을 라벨 리스트에 저장해준다.
        classLabelVector.append(int(listFromLine[-1]))
        index += 1
    return returnMat,classLabelVector
```