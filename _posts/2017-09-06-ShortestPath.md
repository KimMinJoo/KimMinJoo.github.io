---
layout: post
title: 알고리즘스터디] Greedy Algorithm
---

## 탐욕 알고리즘 (Greedy Algorithm)

탐욕알고리즘의 경우 그 순간 최적의 해를 선택하는 알고리즘으로 많이 알고있습니다.<br>
하지만 탐욕알고리즘은 한번 선택한 결정을 바꾸지 않는 알고리즘입니다.

### 탐욕 알고리즘의 패턴
아무것도 가지지않은 집합으로 시작해 반복문을 돌며 순간순간 결정을 집합에 추가해 나가고 마지막에 나온 집합을 해로 반환한다.

#### 탐욕 알고리즘 패턴 예시
- C : 문제의 조건
- S : 문제의 답
- U : S를 구성할 수 있는 모든 원소의 집합

```java
S = {};
for (u in U) {
	if (u is solution) {
		S = S + {u}
	}
	
	if (is complete) {
		return S;
	}
}
```
### 탐욕 알고리즘의 성질
- 한번 선택한 결정을 바꾸지 않으므로 성능이 뛰어난 알고리즘이 많다.<br>
- 그 순간순간 답을 찾기때문에 항상 최적의 답을 찾는 알고리즘은 아닐 수 있다.<br>

### 그래프(Graph)
그래프는 노드와 간선을 이용한 복잡한 현실 세계를 손쉽게 나타낼 수 있어 여러 자료구조중 표현능력이 가장 뛰어나다.<br>


### 용어 설명
탐욕알고리즘에 대해 설명하기전에 몇 가지 자료구조에 대해 설명하겠다.<br>

- 노드(Node) : 정점을 의미하며 Vertex라고도 한다.<br>
- 에지(Edge) : 정점간의 관계를 나타낸다.<br>

아래의 그림1은 노드와 에지를 표현한 그림이다.<br>
<img src="https://github.com/KimMinJoo/KimMinJoo.github.io/blob/master/images/graph.jpg?raw=true"/>
그림1. 노드와 에지

- 그래프(Graph) : 그래프란 노드집합과 에지집합으로 이루어진 자료구조를 뜻한다. 둘 중 공집합이 존재하더라도 그래프이다.<br>
간단히 표현한다면 (V,E)로 표현할 수 있다.
- 숲(Forest) : 순환이 존재하지 않는 그래프를 의미한다.(Acyclic Graph)
- 나무(Tree) : 순환이 존재하지않으며 모든 노드가 연결된 그래프를 의미한다.(Connected Acyclic Graph)
- 신장 트리(Spanning Tree) : 어떤 그래프의 서브 그래프중 모든 노드를 포함하는 Tree를 의미한다.<br>
아래는 신장트리의 예이다.

<img src="https://github.com/KimMinJoo/KimMinJoo.github.io/blob/master/images/minimum_spanning_trees.svg.png?raw=true"/>
그림2. 그래프와 신장트리

### 다익스트라 알고리즘(Dijkstra Algorithm)
다익스트라 알고리즘은 최단거리를 찾는 알고리즘중에 가장 널리 알려진 알고리즘이다.<br>
다익스트라 알고리즘의 아이디어는 어느 한 노드 V에서 가장 가까운 노드 K개를 알고 있을때,<br>
K+1번째 가까운 노드는 내가 알고있는 K개의 노드 혹은 V와 직접 연결되어있다는 것이다.

#### 다익스트라 알고리즘의 사용 조건
- 모든 간선의 비용이 양수이어야 한다.
- Direct Graph 이어야 한다. UnDirected Graph일 경우 Directed Graph로 변환 후 사용해야 한다.

#### 용어설명
코드 설명전에 설명에 쓰일 용어
- 거리 : 간선의 비용
- G : 입력받은 Graph
- V : 입력받은 Graph의 모든 노드 집합
- v0 : 입력받은 시작노드
- g(v1, v2) : v1에서부터 v2까지의 거리, 연결되어 있지않다면 ∞를 반환
- dmin(v) : v0에서부터 v까지의 현재 알고있는 최소 거리를 저장한 집합
- T : v0에서부터 최소거리를 아는 노드들의 집합
- min(param1, param2) : param1, param2중 작은 값을 반환


### Pseudo Code
```java
for (v in V) { 
	dmin(v) = g(V0,v)
} 
T = {v0}
while (T의 원소 개수 != n) {
	T에 속하지 않는 노드중 최소 dmin값을 가진 노드 u 선택.
	 T = T + {u} 
	 for T에 속하지 않는 노드 w { 
		dmin(w) = min(dmin(w),dmin(u) + g(u,w))
	} 
}
```

### 증명
다익스트라 알고리즘을 증명할 땐 아래의 두 사실을 전제조건으로 한다.<br>
- 어떤 노드 u가 T에 속할 때 dmin(u)는 실제 최단경로 길이이다.
- 어떤 노드 u가 T에 속하지 않을 때 dmin(u)는 T에 속한 노드들만 거쳐서 u까지 가는 최단 경로의 길이이다.
<br>
이 두가지를 전제조건으로 하는 이유는 첫번째 전제를 만족한다면 이 알고리즘이 증명되기 때문이다.<br>
Pseudo Code를 보면 알고리즘이 끝나는 경우는 T의 원소개수가 n개일 때이다.<br>
즉 T에 모든 노드가 속했고 그 dmin(u)가 최단경로들의 집합이므로 최단경로를 모두 구한 상태가된다.<br>
두번째 전제의 경우 첫번째 전제를 증명하는 과정에 필요하다.<br>
<br>
다익스트라 알고리즘의 증명은 수학적 귀납법을 이용한다.<br>
수학적 귀납법이란 처음에 어떠한 상태를 만족하고 특정할 수 없는 어떤 시점에 그 상태를 또 만족한다면 항상 그 상태를 만족한다는것입니다.<br>
<br>
수학적 귀납법이므로 시작을 보겠습니다.<br>
시작 : T = {v0}<br>
dmin(v0)는 g(v0,v0)이다. 다익스트라 알고리즘의 경우 모든 에지의 비용이 양수이므로 g(v0,v0)는 최단경로이다.<br>
따라서 1번 가정을 만족한다.<br>
v0가 아닌 노드들을 w라고 한다.<br>
dmin(w)는 초기화 과정에 따라 g(v0, w)이다.<br> 즉 T에 속한 v0를 거쳐서 가는 최단경로의 길이이다.<br>
따라서 2번 가정도 만족한다.<br>
<br>
스텝 : T = T + {u}<br>
어떠한 시점에 T에 어떤 노드 u가 추가되는 경우이다.<br>
이때 위의 전제조건을 만족해야한다.<br>
먼저 첫번째 전제조건이 맞는지 보겠다.<br>
두번제 전제조건에 따라 dmin(u)는 T에 속한 노드만을 거쳐서 u까지 가는 최단 경로이다.<br>
그리고 예를 들어 u까지가는 실제 최단경로가 dmin(u)가아니라 T에 속하는 노드만을 거쳐서 가는게 아니라 T에 속하지 않는 노드들을 거친다고해보자.<br>
이때 실제최단경로에 T에 속하지 않으면서 T와 가장 가까이 있는 노드를 x라고 해보자.<br>
그럼 실제최단경로는 v0 -> ... -> x -> ... -> u와 같은 형태를 띄게 된다.<br>
이경우 dmin(u) > 실제최단경로 -> dmin(x)이다.<br>
그럼 '알고리즘의 T에 속하지 않는 노드중 최소 dmin값을 가진 노드 u선택'에 모순이 생긴다.<br>
따라서 어떤 시점에 T에 새로 속하게 되는 u의 dmin(u)는 실제최단경로이다.<br>
<br>
두번째 전제는 첫번째 전제를 증명할 때 dmin(u) > dmin(x) 라고 장담할 수 있게 해준다.<br>
두번째 전제의 증명은 아래의 단계로 나뉜다.<br>
1. dmin()은 T에 속한 노드들만 거쳐가는 경로이다.<br>
dmin()의 경우 dmin(w) = min(dmin(w), dmin(u) + g(u, w))에서 변한다.<br>
dmin()이 변하는 경우는 dmin(w)가 dmin(u) + g(u, w)보다 작을 경우인데 이때도 결국 T에 있는 노드들을 통한 경로로 변경된다.<br>
따라서 항상 T에 속한 노드들만 거쳐서 가는 경로이다.<br>
2. dmin()은 T에 속한 노드들만 거쳐가는 '최단경로'이다.<br>
dmin()이 업데이트 될 때 T에 추가된 노드는 u뿐이다.<br>
따라서 모든 dmin()값을 갱신할 때 u를 고려해야한다.<br>
u를 거쳐 T에 속한 다른 노드 x를 거쳐 w로 갈 경우가 존재할 수 있다.<br>
이경우 경로를 적어보면 v0 -> ... -> u -> ... -> x -> w와 같이 나타낼 수 있다.<br>
하지만 이때 x는 u보다 먼저 T에 추가된 노드이므로 dmin(x)는 dmin(u)보다 작다.<br>
또한 dmin(x), v0 -> ... -> x에는 u는 존재하지 않는다.<br>
즉 v0 -> ... -> u -> ... -> x -> w는 dmin(x) + g(x,w)보다 작고 dmin(x) + g(x,w)의 경우 x가 T에 추가될 당시 고려되었다.<br>
따라서 저런 경우의 수는 고려할 필요가 없다.<br>
따라서 dmi()을 T에 속한 노드들만 거쳐가는 '최단경로'로 고려할때 새로 추가된 노드 u만 고려해주면된다.<br>
<br>
이렇게 전제를 모두 만족하므로 다익스트라 알고리즘은 최단경로를 구하는 알고리즘이다.<br>

### 최소 신장 트리(Minimum Spanning Tree)
최소신장트리(이하 MST)는 신장트리중 에지들의 비용이 가장 적은 신장트리를 의미한다.

### 프림 알고리즘(Prim Algorithm)
프림 알고리즘은 Tree를 유지하면서 조건에 맞는 에지를 하나씩 추가해나가며 MST를 완성해나가는 방식이다.

#### 용어 설명
코드 설명전에 설명에 쓰일 용어
- G : 입력받을 Connected Graph
- S : 해를 가질 집합
- U : 조건 비교를 하기 위한 노드 집합
- V : G의 노드 집합

### Pseudo Code
```java
S = {}
U = {시작노드}
while (U.equals(V) == false) {
	U에 속한 어느 한 노드 u와 V에서 U에 속하지 않은 어느 한 노드 v를 잇는 에지중 최소의 비용을 가진 에지 uv를 구한다.
	S = S + {uv}
	U = U + {v}
}
```

### 증명
프림 알고리즘또한 수학적 귀납법을 사용해 증명합니다.<br>
프림 알고리즘을 증명할 땐 아래의 아래의 사실을 전제조건으로 한다.<br>
- 집합 S는 항상 적어도 하나의 MST의 서브트리이다.<br>
위의 사실이 증명되었을 때 MST를 구하는 알고리즘인 이유는 프림 알고리즘의 경우 끝나는 시점이 항상 같다.<br>
while문안에 조건이 false가 되었을 때 즉 U와 V가 같게 되었을 때이다.<br>
즉 위의 사실이 항상 만족된다면 종료시점 즉 U가 V와 같을때 S가 MST의 서브트리라면 S는 MST가 된다.<br>
<br>
시작 - S는 공집합이므로 정답MST(이하 T)의 서브트리이다.<br>
<br>
스텝 - 반복문을 한 번 실행하고 나면 S에 e(uv)라는 에지가 추가된다고하자.<br>
그리고 그 집합을 S'라고 하면 아래와 같은 두가지 경우가 나올 수 있다.<br>
- S'가 T의 서브트리일경우<br>
문제가 되지않으므로 계속 진행한다.<br>
- S'가 T의 서브트리가 아닐 경우.<br>
T에 e라는 에지를 추가하고 그 그래프를 T'라고 하자.<br>
T는 MST였는데 e라는 에지가 추가되었으므로 노드와 에지의 수가 같아 무조건 순환이 생기게 된다.<br>
여기선 다시 3가지 경우가 생길 수 있다.<br>
    - 순환의 에지중 하나가 e의 비용보다 클 경우.<br>
    이 경우 T는 MST인데 그 MST에서 e의 비용보다 큰 에지를 빼고 e를 넣을 경우 비용이 더 작은 Spanning Tree가 생기므로 모순이 생긴다.<br>
    따라서 이 경우는 존재할 수 없다.<br>
    - 순환의 에지 중 하나가 e의 비용과 같을 경우<br>
    T'에서 비용이 같은 에지를 빼고 e를 넣으면 기존의 T와는 다르지만 MST가 된다.<br>
    따라서 T를 교체해서 진행하면 된다.<br>
    - 순환의 모든 에지가 e의 비용보다 작은 경우<br>
    순환에 있는 모든 에지들중 S에 속하지 않는 에지는 e를 제외하고서 1개이상 무조건 존재한다.<br>
    순환에 있는 모든 에지들중 e를 제외하고 S에 속하지 않은게 없다면,<br>
    U에 속한 노드와 V에서 U에 속하지 않은 노드를 잇는 에지로서 e가 선택 될 수 없다.<br>
    따라서 순환에는 S에 속하지 않은 에지가 2개이상 존재하고 그 중 e가 제일 작지 않다면 e가 선택되지 않으므로 이 경우는 존재할 수 없다. 
결국 어느 경우에서든 S'는 어떤 MST의 서브트리가 되기때문에 전제조건에 만족한다.
즉 프림알고리즘은 MST를 구하는 알고리즘이다.

### 크루스칼 알고리즘 (Kruskal Algorithm)
크루스칼 알고리즘은 앞에서 얘기했던 탐욕알고리즘의 패턴과 정확히 일치한다.<br>
최소신장트리를 구하는 알고리즘 중에서 가장 직관적인 알고리즘이다.